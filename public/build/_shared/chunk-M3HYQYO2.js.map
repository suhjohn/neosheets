{
  "version": 3,
  "sources": ["../../../@/state/common.ts", "../../../@/state/keyboard.ts", "../../../@/lib/llm.ts", "../../../@/types/sheet.ts", "../../../@/lib/ast/lexer.ts", "../../../@/lib/ast/parser.ts", "../../../@/lib/ast/eval.ts", "../../../@/lib/table/formula.ts", "../../../@/state/update.ts", "../../../@/state/sheetReducer.ts", "../../../@/hooks/useSpreadsheetes.ts"],
  "sourcesContent": ["// @/state/common.ts\nimport { type SheetState } from \"@/types/sheet\";\n\nexport const handleSelectedToEditing = (state: SheetState): SheetState => {\n  if (!state.selectedCellPosition) {\n    return state;\n  }\n  const hasFormula =\n    state.cellStates[state.selectedCellPosition.col][\n      state.selectedCellPosition.row\n    ]?.formula !== undefined &&\n    state.cellStates[state.selectedCellPosition.col][\n      state.selectedCellPosition.row\n    ].formula !== \"\";\n  return {\n    ...state,\n    editingCellPosition: state.selectedCellPosition,\n    editingValue: hasFormula\n      ? `${\n          state.cellStates[state.selectedCellPosition.col][\n            state.selectedCellPosition.row\n          ]?.formula\n        }`\n      : state.cellStates[state.selectedCellPosition.col][\n          state.selectedCellPosition.row\n        ]?.value || \"\",\n  };\n};\n", "// @/state/keyboard.ts\nimport { calculateTextHeight, getSortedCellRange } from \"@/lib/utils\";\nimport {\n  CellState,\n  ClearCellsAction,\n  CopyCellsAction,\n  PasteCellsAction,\n  type CellAddress,\n  type SheetState,\n} from \"@/types/sheet\";\nimport { handleSelectedToEditing } from \"./common\";\n// @/state/sheetReducer.ts\nimport {\n  DEFAULT_CELL_BORDER_WIDTH,\n  DEFAULT_CELL_HEIGHT,\n  DEFAULT_CELL_PADDING,\n  DEFAULT_COLUMN_WIDTH,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_LINE_HEIGHT,\n} from \"@/constants\";\nimport { applyAction } from \"./sheetReducer\";\n\nexport const handleCopy = (\n  action: CopyCellsAction,\n  state: SheetState\n): SheetState => {\n  const { start, end } = action.payload;\n  const { start: sortedStart, end: sortedEnd } = getSortedCellRange({\n    maybeStart: start,\n    maybeEnd: end,\n  });\n\n  const copiedCells: CellState[][] = [];\n  for (let row = sortedStart.row; row <= sortedEnd.row; row++) {\n    const rowData: CellState[] = [];\n    for (let col = sortedStart.col; col <= sortedEnd.col; col++) {\n      const cell = state.cellStates[col]?.[row] || {\n        value: \"\",\n        display: \"hide\",\n      };\n      rowData.push({ ...cell });\n    }\n    copiedCells.push(rowData);\n  }\n\n  return {\n    ...state,\n    clipboard: {\n      cells: copiedCells,\n      start: sortedStart,\n      end: sortedEnd,\n    },\n    showClipboard: true,\n  };\n};\n\nexport const handlePaste = (\n  action: PasteCellsAction,\n  state: SheetState\n): SheetState => {\n  if (!state.clipboard) {\n    return state; // Nothing to paste\n  }\n\n  const { target } = action.payload;\n  const { cells } = state.clipboard;\n\n  const numRows = cells.length;\n  const numCols = cells[0]?.length || 0;\n\n  const endRow = target.row + numRows - 1;\n  const endCol = target.col + numCols - 1;\n\n  const newCellStates = [...state.cellStates];\n  const newRowStates = { ...state.rowStates };\n\n  // Optionally expand the sheet if paste exceeds current boundaries\n  let updatedRowCount = state.rowCount;\n  const updatedColumnCount = state.cellStates.length;\n\n  if (endRow >= updatedRowCount) {\n    updatedRowCount = endRow + 1;\n  }\n\n  if (endCol >= updatedColumnCount) {\n    // Expand cellStates and headerStates\n    for (let col = updatedColumnCount; col <= endCol; col++) {\n      newCellStates[col] = {};\n      state.headerStates[col] = {\n        value: String.fromCharCode(65 + col),\n        type: \"text\",\n        width: DEFAULT_COLUMN_WIDTH, // Ensure DEFAULT_COLUMN_WIDTH is defined\n      };\n    }\n  }\n\n  // Update rowCount if necessary\n  // This assumes that rowCount is used elsewhere to determine sheet dimensions\n  const finalRowCount = updatedRowCount;\n\n  cells.forEach((rowData, rowIndex) => {\n    rowData.forEach((cell, colIndex) => {\n      const pasteRow = target.row + rowIndex;\n      const pasteCol = target.col + colIndex;\n\n      // Skip if pasteRow or pasteCol exceeds boundaries even after expansion\n      if (pasteCol >= newCellStates.length || pasteRow >= finalRowCount) {\n        return;\n      }\n\n      newCellStates[pasteCol] = {\n        ...newCellStates[pasteCol],\n        [pasteRow]: { ...cell },\n      };\n\n      // Recalculate row height if necessary\n      const textWidth =\n        state.headerStates[pasteCol].width -\n        DEFAULT_CELL_BORDER_WIDTH * 4 -\n        DEFAULT_CELL_PADDING * 4;\n      const height = calculateTextHeight({\n        text: cell.value,\n        width: textWidth,\n        font: `${DEFAULT_FONT_SIZE}px ${DEFAULT_FONT_FAMILY}`,\n        display: cell.display,\n        lineHeight: DEFAULT_LINE_HEIGHT,\n      });\n\n      newRowStates[pasteRow] = {\n        ...newRowStates[pasteRow],\n        height: Math.max(\n          newRowStates[pasteRow]?.height || 0,\n          height,\n          DEFAULT_CELL_HEIGHT\n        ),\n      };\n    });\n  });\n\n  return {\n    ...state,\n    cellStates: newCellStates,\n    rowStates: newRowStates,\n    rowCount: finalRowCount,\n    showClipboard: false,\n    selectedCellPosition: target,\n    selectedCellRange: {\n      start: target,\n      end: { row: endRow, col: endCol },\n    },\n  };\n};\n\nexport const handleClear = (action: ClearCellsAction, state: SheetState) => {\n  const { start, end } = action.payload;\n  const { start: sortedStart, end: sortedEnd } = getSortedCellRange({\n    maybeStart: start,\n    maybeEnd: end,\n  });\n  return {\n    ...state,\n    cellStates: state.cellStates.map((column, colIndex) => {\n      const newColumn = { ...column };\n      for (\n        let rowIndex = sortedStart.row;\n        rowIndex <= sortedEnd.row;\n        rowIndex++\n      ) {\n        if (colIndex >= sortedStart.col && colIndex <= sortedEnd.col) {\n          newColumn[rowIndex] = {\n            value: \"\",\n            display: \"hide\",\n          };\n        }\n      }\n      return newColumn;\n    }),\n  };\n};\n\nconst keyMap: Record<string, (state: SheetState) => SheetState> = {\n  ArrowUp: (state: SheetState) => handleMoveSelectedCellPosition(state, \"up\"),\n  \"Shift+ArrowUp\": (state: SheetState) =>\n    handleExpandSelectedRange(state, \"up\"),\n  ArrowDown: (state: SheetState) =>\n    handleMoveSelectedCellPosition(state, \"down\"),\n  \"Shift+ArrowDown\": (state: SheetState) =>\n    handleExpandSelectedRange(state, \"down\"),\n  ArrowLeft: (state: SheetState) =>\n    handleMoveSelectedCellPosition(state, \"left\"),\n  \"Shift+ArrowLeft\": (state: SheetState) =>\n    handleExpandSelectedRange(state, \"left\"),\n  ArrowRight: (state: SheetState) =>\n    handleMoveSelectedCellPosition(state, \"right\"),\n  \"Shift+ArrowRight\": (state: SheetState) =>\n    handleExpandSelectedRange(state, \"right\"),\n  Enter: (state: SheetState) => {\n    if (state.editingCellPosition) {\n      return handleMoveSelectedCellPosition(state, \"down\");\n    }\n    if (state.selectedCellPosition) {\n      return handleSelectedToEditing(state);\n    }\n    return state;\n  },\n  Backspace: (state: SheetState) => {\n    if (state.selectedRows.length > 0) {\n      return handleClear(\n        {\n          type: \"CLEAR_CELLS\",\n          payload: {\n            start: {\n              row: state.selectedRows[0],\n              col: 0,\n            },\n            end: {\n              row: state.selectedRows[state.selectedRows.length - 1],\n              col: state.headerStates.length - 1,\n            },\n          },\n        },\n        state\n      );\n    } else if (state.selectedCellRange && !state.editingCellPosition) {\n      return handleClear(\n        {\n          type: \"CLEAR_CELLS\",\n          payload: state.selectedCellRange,\n        },\n        state\n      );\n    } else if (state.selectedCellPosition && !state.editingCellPosition) {\n      return handleClear(\n        {\n          type: \"CLEAR_CELLS\",\n          payload: {\n            start: state.selectedCellPosition,\n            end: state.selectedCellPosition,\n          },\n        },\n        state\n      );\n    }\n    return state;\n  },\n  \"Meta+c\": (state: SheetState) => {\n    if (state.selectedRows.length > 0) {\n      return handleCopy(\n        {\n          type: \"COPY_CELLS\",\n          payload: {\n            start: {\n              row: state.selectedRows[0],\n              col: 0,\n            },\n            end: {\n              row: state.selectedRows[state.selectedRows.length - 1],\n              col: state.headerStates.length - 1,\n            },\n          },\n        },\n        state\n      );\n    } else if (state.selectedCellRange) {\n      return handleCopy(\n        {\n          type: \"COPY_CELLS\",\n          payload: state.selectedCellRange,\n        },\n        state\n      );\n    } else if (state.selectedCellPosition) {\n      return handleCopy(\n        {\n          type: \"COPY_CELLS\",\n          payload: {\n            start: state.selectedCellPosition,\n            end: state.selectedCellPosition,\n          },\n        },\n        state\n      );\n    }\n    return state;\n  },\n  \"Meta+v\": (state: SheetState) => {\n    if (state.clipboard && state.selectedCellPosition) {\n      return handlePaste(\n        {\n          type: \"PASTE_CELLS\",\n          payload: { target: state.selectedCellPosition },\n        },\n        state\n      );\n    }\n    return state;\n  },\n  \"Meta+a\": (state: SheetState) => {\n    const start: CellAddress = { row: 0, col: 0 };\n    const end: CellAddress = {\n      row: state.rowCount - 1,\n      col: state.headerStates.length - 1,\n    };\n    return {\n      ...state,\n      selectedCellRange: { start, end },\n      selectedCellPosition: null,\n      selectedRows: [],\n    };\n  },\n  \"Meta+z\": (state: SheetState) => applyAction(state, { type: \"UNDO\" }),\n  \"Meta+Shift+z\": (state: SheetState) => applyAction(state, { type: \"REDO\" }),\n};\n\nexport const handleTableKeyboardEvent = (\n  state: SheetState,\n  event: React.KeyboardEvent\n): SheetState => {\n  const keyCombo = [\n    event.ctrlKey && \"Ctrl\",\n    event.altKey && \"Alt\",\n    event.shiftKey && \"Shift\",\n    event.metaKey && \"Meta\",\n  ]\n    .filter(Boolean)\n    .sort();\n\n  keyCombo.push(event.key);\n  const command = keyCombo.join(\"+\");\n  const handler = keyMap[command as keyof typeof keyMap];\n  return handler ? handler(state) : state;\n};\n\nconst handleMoveSelectedCellPosition = (\n  state: SheetState,\n  direction: \"up\" | \"down\" | \"left\" | \"right\"\n): SheetState => {\n  if (!state.selectedCellPosition) {\n    return state;\n  }\n  const { row, col } = state.selectedCellPosition;\n  switch (direction) {\n    case \"up\":\n      return {\n        ...state,\n        selectedCellRange: null,\n        selectedCellPosition: {\n          row: Math.max(0, row - 1),\n          col,\n        },\n      };\n    case \"down\":\n      return {\n        ...state,\n        selectedCellRange: null,\n        selectedCellPosition: {\n          row: Math.min(state.rowCount - 1, row + 1),\n          col,\n        },\n      };\n    case \"left\":\n      return {\n        ...state,\n        selectedCellRange: null,\n        selectedCellPosition: {\n          row,\n          col: Math.max(0, col - 1),\n        },\n      };\n    case \"right\":\n      return {\n        ...state,\n        selectedCellRange: null,\n        selectedCellPosition: {\n          row,\n          col: Math.min(state.cellStates.length - 1, col + 1),\n        },\n      };\n  }\n};\n\nconst handleExpandSelectedRange = (\n  state: SheetState,\n  direction: \"up\" | \"down\" | \"left\" | \"right\"\n): SheetState => {\n  if (!state.selectedCellPosition) {\n    return state;\n  }\n\n  const start = state.selectedCellRange?.start ?? state.selectedCellPosition;\n  const end = state.selectedCellRange?.end ?? state.selectedCellPosition;\n\n  let newEnd: CellAddress;\n  switch (direction) {\n    case \"up\":\n      newEnd = { row: Math.max(0, end.row - 1), col: end.col };\n      break;\n    case \"down\":\n      newEnd = { row: Math.min(state.rowCount - 1, end.row + 1), col: end.col };\n      break;\n    case \"left\":\n      newEnd = {\n        row: end.row,\n        col: Math.max(0, end.col - 1),\n      };\n      break;\n    case \"right\":\n      newEnd = {\n        row: end.row,\n        col: Math.min(state.headerStates.length - 1, end.col + 1),\n      };\n      break;\n  }\n\n  return {\n    ...state,\n    selectedCellRange: { start, end: newEnd },\n  };\n};\n", "// @/lib/llm.ts\nimport { Resource } from \"@/types/resource\";\nimport { SecretKeys } from \"@/types/secret\";\nimport { LlmFunctionType } from \"@/types/sheet\";\nimport { extractMustacheVariables } from \"./utils\";\n\n/**\n * Validates that all secretKeyName references in the resource's authorization\n * exist within the provided secretKeys.\n *\n * @param resource - The resource to validate.\n * @param secretKeys - The set of secret keys available.\n * @returns An object indicating validity and any missing keys.\n */\nexport function validateResourceAuthorization(\n  resource: Resource,\n  secretKeys: SecretKeys\n): { isValid: boolean; missingKeys: string[] } {\n  const missingKeys: string[] = [];\n  const { authorization } = resource;\n\n  // Helper function to check if a key exists in secretKeys\n  const keyExists = (keyName: string): boolean => !!secretKeys.body[keyName];\n\n  switch (authorization.authMethod) {\n    case \"bearerToken\":\n      if (!keyExists(authorization.secretKeyName)) {\n        missingKeys.push(authorization.secretKeyName);\n      }\n      break;\n\n    case \"apiKey\":\n      if (!keyExists(authorization.secretKeyName)) {\n        missingKeys.push(authorization.secretKeyName);\n      }\n      break;\n\n    case \"oauth2\":\n      if (!keyExists(authorization.clientIdKeyName)) {\n        missingKeys.push(authorization.clientIdKeyName);\n      }\n      if (!keyExists(authorization.clientSecretKeyName)) {\n        missingKeys.push(authorization.clientSecretKeyName);\n      }\n      break;\n\n    case \"hmac\":\n      if (!keyExists(authorization.accessKeyName)) {\n        missingKeys.push(authorization.accessKeyName);\n      }\n      if (!keyExists(authorization.secretKeyName)) {\n        missingKeys.push(authorization.secretKeyName);\n      }\n      break;\n\n    case \"mtls\":\n      if (!keyExists(authorization.clientCertKeyName)) {\n        missingKeys.push(authorization.clientCertKeyName);\n      }\n      if (!keyExists(authorization.clientKeyKeyName)) {\n        missingKeys.push(authorization.clientKeyKeyName);\n      }\n      break;\n\n    case \"basic\":\n      // Basic Auth may not use SecretKeys\n      break;\n\n    case \"custom\":\n      // Custom auth might have different validation\n      // Implement as needed\n      break;\n\n    default:\n      // Unknown auth method\n      break;\n  }\n\n  return {\n    isValid: missingKeys.length === 0,\n    missingKeys,\n  };\n}\n\nexport const generateFunctionBody = ({\n  functionData,\n  secretKeys,\n}: {\n  functionData: LlmFunctionType & { resource: Resource };\n  secretKeys: SecretKeys;\n}) => {\n  // const isValid = validateResourceAuthorization(\n  //   functionData.resource,\n  //   secretKeys\n  // );\n  // if (!isValid.isValid) {\n  //   throw new Error(`Missing secret keys: ${isValid.missingKeys.join(\", \")}`);\n  // }\n  const { authorization, additionalHeaders: resourceAdditionalHeaders } =\n    functionData.resource;\n\n  // Helper function to safely escape secret keys to prevent injection attacks\n  const escapeSecret = (value: string | undefined): string =>\n    value === undefined ? \"\" : value.replace(/`/g, \"\\\\`\").replace(/\\$/g, \"\\\\$\");\n\n  // Initialize variables to hold secret key values\n  let authorizationHeader = \"\";\n  let additionalHeaders = \"\";\n\n  switch (authorization.authMethod) {\n    case \"bearerToken\": {\n      const bearerToken = secretKeys.body[authorization.secretKeyName];\n      authorizationHeader = `Authorization: \"Bearer ${escapeSecret(\n        bearerToken\n      )}\",`;\n      break;\n    }\n    case \"apiKey\": {\n      const apiKey = secretKeys.body[authorization.secretKeyName];\n      authorizationHeader = `\"${escapeSecret(\n        authorization.apiKeyName\n      )}\": \"${escapeSecret(apiKey)}\",`;\n      break;\n    }\n    case \"oauth2\": {\n      const clientId = secretKeys.body[authorization.clientIdKeyName];\n      const clientSecret = secretKeys.body[authorization.clientSecretKeyName];\n      // Example: Including clientId and clientSecret in the body or headers\n      additionalHeaders += `\"Client-ID\": \"${escapeSecret(clientId)}\",\\n`;\n      additionalHeaders += `\"Client-Secret\": \"${escapeSecret(\n        clientSecret\n      )}\",\\n`;\n      break;\n    }\n    case \"hmac\": {\n      const accessKey = secretKeys.body[authorization.accessKeyName];\n      const secretKey = secretKeys.body[authorization.secretKeyName];\n      // Example: Generating HMAC signature (pseudo-code)\n      additionalHeaders += `\"Access-Key\": \"${escapeSecret(accessKey)}\",\\n`;\n      additionalHeaders += `\"Signature\": \"${escapeSecret(secretKey)}\",\\n`;\n      break;\n    }\n    case \"mtls\": {\n      const clientCert = secretKeys.body[authorization.clientCertKeyName];\n      const clientKey = secretKeys.body[authorization.clientKeyKeyName];\n      // Example: Including certificates in the request (may require different handling)\n      // This is a placeholder as handling certificates usually involves more secure methods\n      additionalHeaders += `\"Client-Cert\": \"${escapeSecret(clientCert)}\",\\n`;\n      additionalHeaders += `\"Client-Key\": \"${escapeSecret(clientKey)}\",\\n`;\n      break;\n    }\n    case \"basic\":\n      // Basic Auth typically uses username and password, not secret keys\n      // Handle accordingly if needed\n      break;\n    case \"custom\":\n      // Custom auth might require different handling based on customAuthDetails\n      // Implement as needed\n      break;\n    default:\n      // Handle unknown auth methods if necessary\n      break;\n  }\n  if (\n    resourceAdditionalHeaders &&\n    Object.keys(resourceAdditionalHeaders).length > 0\n  ) {\n    additionalHeaders += Object.entries(resourceAdditionalHeaders)\n      .map(([key, value]) => `\"${key}\": \"${escapeSecret(value)}\",`)\n      .join(\"\\n\");\n  }\n\n  const variables = Array.from(\n    new Set(\n      functionData.messages.flatMap((message) =>\n        extractMustacheVariables(message.content)\n      )\n    )\n  );\n  const argsType = `type Args = {\n    ${variables.map((varName) => `  ${varName}: string;`).join(\"\\n\")}\n    };\\n`;\n\n  // Generate the function body with injected headers and body\n  const functionBody = `function getValueAtPath(\n      data: any,\n      path: Array<string | number>\n    ): any {\n      let current: JsonValue | undefined = data;\n      for (const key of path) {\n        if (\n          current !== undefined &&\n          current !== null &&\n          typeof current === 'object'\n        ) {\n          current = Array.isArray(current)\n            ? current[key as number]\n            : current[key as string];\n        } else {\n          return undefined; // Not an object or array, or path does not exist\n        }\n      }\n      if (typeof current !== 'string') {\n        return undefined;\n      }\n      return current;\n    }\\n\\n${argsType}\\n\\nasync function run(args: Args) {\n    // Validate that all required args are provided\n    const missingArgs = [${variables\n      .map((v) => `\"${v}\"`)\n      .join(\", \")}].filter(arg => !(arg in args));\n    if (missingArgs.length > 0) {\n      throw new Error(\"Missing arguments: \" + missingArgs.join(\", \"));\n    }\n    // Replace Mustache variables in messages\n    const messages = ${JSON.stringify(\n      functionData.messages,\n      null,\n      2\n    )}.map(message => ({\n      ...message,\n      content: message.content.replace(/{{\\\\s*(\\\\w+)\\\\s*}}/g, (_, key) => {\n        if (key in args) {\n          return args[key];\n        } else {\n          return \"\";\n        }\n      })\n    }));\n\n    const requestBody = {\n      messages: messages,\n      model: \"${functionData.model}\",\n      ${\n        functionData.args\n          ? `...${JSON.stringify(JSON.parse(functionData.args))},`\n          : \"\"\n      }\n    };\n    const response = await fetch(\"${functionData.resource.apiUrl}\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"anthropic-dangerous-direct-browser-access\": \"true\",\n        ${authorizationHeader}\n        ${additionalHeaders}\n      },\n      body: JSON.stringify(requestBody, null, 2),\n    });\n\n    if (!response.ok) {\n      throw new Error(\\`Request failed with status \\${response.status}\\`);\n    }\n    \n\n    const data = await response.json();\n    ${\n      functionData.outputPath !== undefined\n        ? `\n      // Extract value using outputPath\n      const result = getValueAtPath(data, ${JSON.stringify(functionData.outputPath)});\n      return result;\n      `\n        : `\n      return data;\n      `\n    }\n  }`;\n  return functionBody;\n};\n", "// @/types/sheet.ts\nimport { z } from \"zod\";\nimport { type ChatMessage } from \"./chat\";\nimport { Resource } from \"./resource\";\n\nexport const CellDisplaySchema = z.union([\n  z.literal(\"hide\"),\n  z.literal(\"wrap\"),\n]);\n\nexport const CellStateSchema = z.object({\n  value: z.string(),\n  display: CellDisplaySchema,\n  type: z\n    .union([\n      z.literal(\"string\"),\n      z.literal(\"number\"),\n      z.literal(\"bigint\"),\n      z.literal(\"boolean\"),\n      z.literal(\"symbol\"),\n      z.literal(\"undefined\"),\n      z.literal(\"object\"),\n      z.literal(\"function\"),\n    ])\n    .optional(),\n  promise: z.promise(z.any()).optional(),\n  fontFamily: z.string().optional(),\n  fontSize: z.number().optional(),\n  formula: z.string().optional(),\n  dependencies: z.set(z.string()).optional(),\n  error: z.literal(\"circular_dependency\").optional(),\n});\n\nexport type CellDisplay = z.infer<typeof CellDisplaySchema>;\n\nexport const CellAddressSchema = z.object({\n  row: z.number(),\n  col: z.number(),\n});\n\nexport const ColumnStateSchema = z.object({\n  value: z.string(),\n  type: z.string(),\n  width: z.number(),\n});\n\nexport const RowStateSchema = z.object({\n  hidden: z.boolean(),\n  height: z.number(),\n  specifiedHeight: z.number().nullable(),\n});\n\nexport const ClipboardDataSchema = z.object({\n  cells: z.array(z.array(CellStateSchema)),\n  start: CellAddressSchema,\n  end: CellAddressSchema,\n});\n\nexport const CellStatesSchema = z.record(z.number(), CellStateSchema);\n\nexport const SheetActionSchema = z.discriminatedUnion(\"type\", [\n  z.object({\n    type: z.literal(\"SET_SELECTED_CELL_POSITION\"),\n    payload: CellAddressSchema.nullable(),\n  }),\n  z.object({\n    type: z.literal(\"SET_EDITING_CELL_POSITION\"),\n    payload: CellAddressSchema.nullable(),\n  }),\n  z.object({\n    type: z.literal(\"SET_EDITING_VALUE\"),\n    payload: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"SET_CELLS\"),\n    payload: z.record(z.string(), CellStateSchema),\n  }),\n  z.object({\n    type: z.literal(\"SET_SELECTED_CELL_RANGE\"),\n    payload: z\n      .object({\n        start: CellAddressSchema,\n        end: CellAddressSchema,\n      })\n      .nullable(),\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_RESIZE_COLUMN\"),\n    payload: z.object({\n      colIndex: z.number(),\n      width: z.number(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_DRAG_CELLS\"),\n    payload: CellAddressSchema,\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_UNCLICKED_TO_CLICKED_CELL\"),\n    payload: CellAddressSchema,\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_DOUBLE_CLICK_CELL\"),\n    payload: CellAddressSchema,\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_UPDATE_CELL\"),\n    payload: CellAddressSchema.extend({\n      value: z.string(),\n      display: CellDisplaySchema.optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_UPDATE_CELL_RANGE\"),\n    payload: z.object({\n      range: z.object({\n        start: CellAddressSchema,\n        end: CellAddressSchema,\n      }),\n      value: z.string().optional(),\n      display: CellDisplaySchema.optional(),\n      previousData: z.record(z.string(), CellStateSchema).optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_TABLE_KEYBOARD_EVENT\"),\n    payload: z.any(), // This should be more specific, but we can't easily represent a React.KeyboardEvent in Zod\n  }),\n  z.object({\n    type: z.literal(\"INSERT_ROW\"),\n    payload: z.object({\n      rowIndex: z.number(),\n      rowData: z\n        .object({\n          rowState: RowStateSchema,\n          cellStates: z.array(CellStateSchema),\n        })\n        .optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"INSERT_ROWS\"),\n    payload: z.object({\n      rows: z.array(\n        z.object({\n          rowIndex: z.number(),\n          rowData: z\n            .object({\n              rowState: RowStateSchema,\n              cellStates: z.array(CellStateSchema),\n            })\n            .optional(),\n        })\n      ),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"DELETE_ROWS\"),\n    payload: z.array(z.number()),\n  }),\n  z.object({\n    type: z.literal(\"INSERT_COLUMN\"),\n    payload: z.object({\n      colIndex: z.number(),\n      columnState: ColumnStateSchema.optional(),\n      cellStates: z.record(z.string(), CellStateSchema).optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"DELETE_COLUMN\"),\n    payload: z.number(),\n  }),\n  z.object({\n    type: z.literal(\"MOVE_COLUMN\"),\n    payload: z.object({\n      fromIndex: z.number(),\n      toIndex: z.number(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"CLEAR_CELLS\"),\n    payload: z.object({\n      start: CellAddressSchema,\n      end: CellAddressSchema,\n    }),\n  }),\n  z.object({\n    type: z.literal(\"FORMAT_CELLS\"),\n    payload: z.object({\n      start: CellAddressSchema,\n      end: CellAddressSchema,\n      fontFamily: z.string(),\n      fontSize: z.number(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_RESIZE_ROWS\"),\n    payload: z.array(\n      z.object({\n        rowIndex: z.number(),\n        height: z.number().nullable(),\n      })\n    ),\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_DRAG_ROWS\"),\n    payload: z.array(z.number()),\n  }),\n  z.object({\n    type: z.literal(\"SET_SHEET_NAME\"),\n    payload: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"COPY_CELLS\"),\n    payload: z.object({\n      start: CellAddressSchema,\n      end: CellAddressSchema,\n    }),\n  }),\n  z.object({\n    type: z.literal(\"PASTE_CELLS\"),\n    payload: z.object({\n      target: CellAddressSchema,\n      sourceData: z.record(z.string(), CellStateSchema).optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"UNDO\"),\n    payload: z.any(),\n  }),\n  z.object({\n    type: z.literal(\"REDO\"),\n    payload: z.any(),\n  }),\n  z.object({\n    type: z.literal(\"HANDLE_BLUR_CELL\"),\n    payload: z.any(),\n  }),\n  z.object({\n    type: z.literal(\"INITIATE_AUTOFILL\"),\n    payload: z.object({\n      row: z.number(),\n      col: z.number(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"UPDATE_AUTOFILL_TARGET\"),\n    payload: z.object({\n      endRow: z.number(),\n      endCol: z.number(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"PERFORM_AUTOFILL\"),\n    payload: z.object({\n      fillRange: z.object({\n        start: CellAddressSchema,\n        end: CellAddressSchema,\n      }),\n    }),\n  }),\n]);\n\nexport type SheetAction = z.infer<typeof SheetActionSchema>;\n\nexport const SheetStateSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  cellStates: z.array(CellStatesSchema),\n  selectedCellPosition: z.nullable(CellAddressSchema),\n  editingCellPosition: z.nullable(CellAddressSchema),\n  headerStates: z.array(ColumnStateSchema),\n  rowStates: z.record(RowStateSchema),\n  rowCount: z.number(),\n  editingValue: z.string(),\n  selectedCellRange: z.nullable(\n    z.object({\n      start: CellAddressSchema,\n      end: CellAddressSchema,\n    })\n  ),\n  selectedRows: z.array(z.number()),\n  clipboard: z.nullable(ClipboardDataSchema),\n  showClipboard: z.boolean().optional(),\n  promises: z\n    .record(z.string(), z.record(z.string(), z.promise(z.any())))\n    .nullable(),\n  undoStack: z.array(SheetActionSchema).default([]),\n  redoStack: z.array(SheetActionSchema).default([]),\n  autofillTarget: z.nullable(CellAddressSchema),\n});\n\nexport type ClipboardData = z.infer<typeof ClipboardDataSchema>;\n\nexport type SheetState = z.infer<typeof SheetStateSchema>;\n\nexport type CellState = z.infer<typeof CellStateSchema>;\n\nexport type CellAddress = z.infer<typeof CellAddressSchema>;\n\nexport type CellStates = z.infer<typeof CellStatesSchema>;\n\nexport type ColumnState = z.infer<typeof ColumnStateSchema>;\n\n// export type RowState = {\n//   hidden: boolean;\n//   height: number; // auto calculated height for the row. Finds the max height of all cells in the row.\n//   specifiedHeight: number | null; // height specified by the user. If null, the height is auto calculated.\n// };\n\nexport type RowState = z.infer<typeof RowStateSchema>;\n\nexport type BasicFunctionType = {\n  id: string;\n  functionName: string;\n  description: string;\n  functionBody: string;\n  type: \"function\";\n  createdBy: string;\n  createdAt: string;\n  updatedAt: string;\n};\n\nexport type LlmFunctionType = {\n  id: string;\n  functionName: string;\n  description: string;\n  functionBody: string;\n  type: \"llm\";\n  resourceId: string;\n  model: string;\n  messages: ChatMessage[];\n  prompt: string | null;\n  args?: string;\n  outputPath?: (string | number)[];\n  createdBy: string;\n  createdAt: string;\n  updatedAt: string;\n};\n\nexport type FunctionType = (BasicFunctionType | LlmFunctionType) & {\n  resource?: Resource | null;\n};\n\nexport type FunctionBindingType = {\n  name: string;\n  functionId: string;\n  isCustom: boolean;\n};\n\nexport type UpdateCellArgsType = CellAddress & {\n  value: string;\n  display?: CellDisplay;\n};\n\nexport type FunctionBindingsType = {\n  sheetId: string;\n  functionBindings: FunctionBindingType[];\n};\n\nexport type FunctionBindingsWithFunctionsType = {\n  sheetId: string;\n  functionBindings: (FunctionBindingType & {\n    function: FunctionType | null;\n  })[];\n};\n\nexport type CopyCellsAction = {\n  type: \"COPY_CELLS\";\n  payload: { start: CellAddress; end: CellAddress };\n};\n\nexport type PasteCellsAction = {\n  type: \"PASTE_CELLS\";\n  payload: {\n    target: CellAddress;\n    sourceData?: { [key: string]: CellState }; // Added field for inverse action\n  };\n};\n\nexport type ClearCellsAction = {\n  type: \"CLEAR_CELLS\";\n  payload: { start: CellAddress; end: CellAddress };\n};\n\nexport type InsertColumnPayload = {\n  colIndex: number;\n  columnState?: ColumnState;\n  cellStates?: CellStates; // Changed from CellState[] to CellStates (Record<number, CellState>)\n};\n\nexport function cellAddressToString(address: CellAddress): string {\n  return `${String.fromCharCode(65 + address.col)}${address.row + 1}`;\n}\n\nexport function stringToCellAddress(str: string): CellAddress {\n  const match = str.match(/([A-Z]+)(\\d+)/);\n  if (!match) throw new Error(`Invalid cell address: ${str}`);\n  const [, col, row] = match;\n  return {\n    col:\n      col\n        .split(\"\")\n        .reduce((acc, char) => acc * 26 + char.charCodeAt(0) - 64, 0) - 1,\n    row: parseInt(row) - 1,\n  };\n}\n\nexport const CreateSpreadsheetArgs = z.object({\n  name: z.string().min(1).optional().default(\"Untitled Spreadsheet\"),\n  // Add more fields if necessary, such as initial sheets\n});\n\nexport type CreateSpreadsheetArgs = z.infer<typeof CreateSpreadsheetArgs>;\n\n/**\n * SpreadsheetSchema\n *\n * Schema representing a spreadsheet.\n */\nexport const SpreadsheetSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  lastOpenedAt: z.string().datetime(),\n  sheets: z.array(SheetStateSchema).min(1),\n});\n\nexport type Spreadsheet = z.infer<typeof SpreadsheetSchema>;", "// lexer.ts\nimport { type FunctionBindingsType, type Token } from \"@/types/ast\";\n\nexport function tokenize({\n  input,\n  functionBindings,\n}: {\n  input: string;\n  functionBindings: FunctionBindingsType;\n}): Token[] {\n  const tokens: Token[] = [];\n  let current = 0;\n\n  while (current < input.length) {\n    let char = input[current];\n\n    if (/\\s/.test(char)) {\n      current++;\n      continue;\n    }\n\n    if (/\\d/.test(char)) {\n      let value = \"\";\n      while (current < input.length && /\\d/.test(input[current])) {\n        value += input[current];\n        current++;\n      }\n      tokens.push({ type: \"NUMBER\", value });\n      continue;\n    }\n\n    if (/[A-Z]/i.test(char)) {\n      let value = \"\";\n      while (current < input.length && /[A-Z0-9]/i.test(input[current])) {\n        value += input[current];\n        current++;\n      }\n\n      // Check if it's a FUNCTION\n      if (functionBindings[value.toUpperCase()]) {\n        tokens.push({ type: \"FUNCTION\", value });\n      }\n      // Check if it's a valid CELL_REF (e.g., A1, B2)\n      else if (/^[A-Z]+[0-9]+$/i.test(value)) {\n        tokens.push({ type: \"CELL_REF\", value });\n      }\n      // Otherwise, it's a general IDENTIFIER\n      else {\n        tokens.push({ type: \"IDENTIFIER\", value });\n      }\n      continue;\n    }\n\n    if (/[+\\-*/]/.test(char)) {\n      tokens.push({ type: \"OPERATOR\", value: char });\n      current++;\n      continue;\n    }\n\n    if (char === \"(\") {\n      tokens.push({ type: \"LPAREN\", value: \"(\" });\n      current++;\n      continue;\n    }\n\n    if (char === \")\") {\n      tokens.push({ type: \"RPAREN\", value: \")\" });\n      current++;\n      continue;\n    }\n\n    if (char === \",\") {\n      tokens.push({ type: \"COMMA\", value: \",\" });\n      current++;\n      continue;\n    }\n\n    if (char === \":\") {\n      tokens.push({ type: \"COLON\", value: \":\" });\n      current++;\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"LBRACE\", value: \"{\" });\n      current++;\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"RBRACE\", value: \"}\" });\n      current++;\n      continue;\n    }\n\n    if (char === '\"') {\n      let value = \"\";\n      current++; // Skip the opening quote\n      char = input[current];\n\n      while (current < input.length && char !== '\"') {\n        value += char;\n        current++;\n        char = input[current];\n      }\n\n      if (char === '\"') {\n        current++; // Skip the closing quote\n      } else {\n        throw new Error(\"Unterminated string literal\");\n      }\n\n      tokens.push({ type: \"STRING\", value });\n      continue;\n    }\n\n    throw new Error(`Unrecognized character: ${char}`);\n  }\n  return tokens;\n}\n", "// parser.ts\nimport {\n  type ASTNode,\n  type BinaryOperationNode,\n  type CellReferenceNode,\n  type FunctionNode,\n  type NumberNode,\n  type ObjectLiteralNode,\n  type RangeNode,\n  type StringNode, // Imported StringNode\n  type Token,\n} from \"../../types/ast\";\n\nfunction parseCellReference(value: string): CellReferenceNode {\n  const match = value.match(/([A-Z]+)(\\d+)/);\n  if (!match) {\n    throw new Error(`Invalid cell reference: ${value}`);\n  }\n  const [, col, row] = match;\n  return {\n    type: \"CellReference\",\n    columnIndex:\n      col\n        .split(\"\")\n        .reduce((acc, char) => acc * 26 + char.charCodeAt(0) - 64, 0) - 1,\n    rowIndex: parseInt(row) - 1,\n  };\n}\n\nexport function parse(tokens: Token[]): ASTNode {\n  let current = 0;\n\n  function parseExpression(): ASTNode {\n    let left = parseTerm();\n\n    while (\n      current < tokens.length &&\n      (tokens[current].value === \"+\" || tokens[current].value === \"-\")\n    ) {\n      const operator = tokens[current].value as \"+\" | \"-\";\n      current++;\n      const right = parseTerm();\n      left = {\n        type: \"BinaryOperation\",\n        operator,\n        left,\n        right,\n      } as BinaryOperationNode;\n    }\n\n    return left;\n  }\n\n  function parseTerm(): ASTNode {\n    let left = parseFactor();\n\n    while (\n      current < tokens.length &&\n      (tokens[current].value === \"*\" || tokens[current].value === \"/\")\n    ) {\n      const operator = tokens[current].value as \"*\" | \"/\";\n      current++;\n      const right = parseFactor();\n      left = {\n        type: \"BinaryOperation\",\n        operator,\n        left,\n        right,\n      } as BinaryOperationNode;\n    }\n\n    return left;\n  }\n\n  function parseFactor(): ASTNode {\n    const token = tokens[current];\n\n    if (token.type === \"NUMBER\") {\n      current++;\n      return { type: \"Number\", value: parseFloat(token.value) } as NumberNode;\n    }\n\n    if (token.type === \"STRING\") {\n      // New Handling for STRING Tokens\n      current++;\n      return { type: \"String\", value: token.value } as StringNode;\n    }\n\n    if (token.type === \"CELL_REF\") {\n      if (current + 1 < tokens.length && tokens[current + 1].type === \"COLON\") {\n        return parseRange();\n      }\n      current++;\n      return parseCellReference(token.value);\n    }\n\n    if (token.type === \"IDENTIFIER\") {\n      // Handle identifiers if necessary\n      throw new Error(`Unexpected identifier: ${token.value}`);\n    }\n\n    if (token.type === \"FUNCTION\") {\n      return parseFunction();\n    }\n\n    if (token.type === \"LPAREN\") {\n      current++; // consume left paren\n      const node = parseExpression();\n      if (tokens[current].type !== \"RPAREN\") {\n        throw new Error(\n          `Expected ')' after expression, got ${tokens[current].type}`\n        );\n      }\n      current++; // consume right paren\n      return node;\n    }\n\n    if (token.type === \"LBRACE\") {\n      return parseObjectLiteral();\n    }\n\n    throw new Error(`Unexpected token: ${JSON.stringify(token)}`);\n  }\n\n  function parseFunction(): FunctionNode {\n    const name = tokens[current].value;\n    current++; // consume function name\n\n    if (tokens[current].type !== \"LPAREN\") {\n      throw new Error(\n        `Expected '(' after function name, got ${tokens[current].type}`\n      );\n    }\n    current++; // consume left paren\n\n    const args: ASTNode[] = [];\n    while (tokens[current].type !== \"RPAREN\") {\n      if (tokens[current].type === \"COMMA\") {\n        current++; // consume comma\n        continue;\n      }\n      if (\n        tokens[current].type === \"CELL_REF\" &&\n        current + 1 < tokens.length &&\n        tokens[current + 1].type === \"COLON\"\n      ) {\n        args.push(parseRange());\n      } else {\n        args.push(parseExpression());\n      }\n    }\n    current++; // consume right paren\n    return { type: \"Function\", name, arguments: args } as FunctionNode;\n  }\n\n  function parseRange(): RangeNode {\n    const start = parseCellReference(tokens[current].value);\n    current++; // consume start cell reference\n\n    if (tokens[current].type !== \"COLON\") {\n      throw new Error(`Expected ':' in range, got ${tokens[current].type}`);\n    }\n    current++; // consume colon\n\n    const end = parseCellReference(tokens[current].value);\n    current++; // consume end cell reference\n\n    return { type: \"Range\", start, end } as RangeNode;\n  }\n\n  function parseObjectLiteral(): ObjectLiteralNode {\n    current++; // consume left brace\n    const properties: { key: string; value: ASTNode }[] = [];\n\n    while (tokens[current].type !== \"RBRACE\") {\n      let key: string;\n\n      // Accept STRING, IDENTIFIER, or FUNCTION as keys\n      if (\n        tokens[current].type === \"STRING\" ||\n        tokens[current].type === \"IDENTIFIER\"\n      ) {\n        key = tokens[current].value;\n        current++; // consume key\n      } else if (tokens[current].type === \"FUNCTION\") {\n        key = tokens[current].value;\n        current++; // consume key\n      } else {\n        throw new Error(\n          `Expected string, identifier, or function key, got ${tokens[current].type}`\n        );\n      }\n\n      if (tokens[current].type !== \"COLON\") {\n        throw new Error(\n          `Expected colon after key in object literal, got ${tokens[current].type}`\n        );\n      }\n      current++; // consume colon\n\n      const value = parseExpression();\n      properties.push({ key, value });\n\n      if (tokens[current].type === \"COMMA\") {\n        current++; // consume comma\n      }\n    }\n\n    current++; // consume right brace\n    return { type: \"ObjectLiteral\", properties };\n  }\n\n  return parseExpression();\n}\n", "// eval.ts\nimport { type ASTNode, type FunctionBindingsType } from \"@/types/ast\";\nimport {\n  cellAddressToString,\n  type CellAddress,\n  type CellStates,\n} from \"@/types/sheet\";\nimport { tokenize } from \"./lexer\";\nimport { parse } from \"./parser\";\n\ndeclare const ts: typeof import(\"typescript\");\n\n// Add this new error class\nexport class CircularDependencyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"CircularDependencyError\";\n  }\n}\n\nfunction evaluateAst(\n  ast: ASTNode,\n  data: CellStates[],\n  currentCell: CellAddress,\n  evaluationChain: Set<string>,\n  functionBindings: FunctionBindingsType\n): string | number | string[] | number[] | (string | number)[] | object {\n  switch (ast.type) {\n    case \"Number\":\n      return ast.value;\n    case \"String\":\n      return ast.value;\n    case \"CellReference\": {\n      // eslint-disable-next-line no-case-declarations\n      const refAddress = cellAddressToString({\n        col: ast.columnIndex,\n        row: ast.rowIndex,\n      });\n      if (evaluationChain.has(refAddress)) {\n        throw new CircularDependencyError(\n          `Circular dependency detected at ${refAddress}`\n        );\n      }\n      evaluationChain.add(refAddress);\n      const cellValue = data[ast.columnIndex]?.[ast.rowIndex]?.value;\n      if (typeof cellValue === \"string\" && cellValue.startsWith(\"=\")) {\n        return evaluateFormula({\n          formula: cellValue,\n          data,\n          currentCell: { col: ast.columnIndex, row: ast.rowIndex },\n          evaluationChain,\n          functionBindings,\n        });\n      }\n      return cellValue !== undefined ? cellValue : 0;\n    }\n    case \"Range\": {\n      const startCell = { col: ast.start.columnIndex, row: ast.start.rowIndex };\n      const endCell = { col: ast.end.columnIndex, row: ast.end.rowIndex };\n      const values = [];\n      for (let col = startCell.col; col <= endCell.col; col++) {\n        for (let row = startCell.row; row <= endCell.row; row++) {\n          values.push(data[col]?.[row]?.value ?? 0);\n        }\n      }\n      return values;\n    }\n    case \"BinaryOperation\": {\n      const left = evaluateAst(\n        ast.left,\n        data,\n        currentCell,\n        evaluationChain,\n        functionBindings\n      ) as number;\n      const right = evaluateAst(\n        ast.right,\n        data,\n        currentCell,\n        evaluationChain,\n        functionBindings\n      ) as number;\n      switch (ast.operator) {\n        case \"+\":\n          return left + right;\n        case \"-\":\n          return left - right;\n        case \"*\":\n          return left * right;\n        case \"/\":\n          return left / right;\n        default:\n          throw new Error(`Unknown operator: ${ast.operator}`);\n      }\n    }\n    case \"Function\": {\n      const args = ast.arguments.map((arg) =>\n        evaluateAst(arg, data, currentCell, evaluationChain, functionBindings)\n      );\n      const functionObj = functionBindings[ast.name.toUpperCase()];\n      if (!functionObj) {\n        throw new Error(`Function ${ast.name} not found`);\n      }\n      const { functionBody } = functionObj;\n      const transpiledCode = ts.transpile(`${functionBody}`);\n\n      // Prepare the argument string for eval\n      let argString: string;\n      if (args.length === 1 && typeof args[0] === \"object\") {\n        // If the argument is an object, stringify it\n        argString = JSON.stringify(args[0]);\n      } else {\n        // For positional arguments, join them with commas\n        argString = args.join(\", \");\n      }\n      // Adjust the function call accordingly\n      const res = new Function(`${transpiledCode};\\nreturn run(${argString});`)();\n      return res;\n    }\n    case \"ObjectLiteral\": {\n      const obj: { [key: string]: unknown } = {};\n      for (const { key, value } of ast.properties) {\n        obj[key] = evaluateAst(\n          value,\n          data,\n          currentCell,\n          evaluationChain,\n          functionBindings\n        ) as string | number | string[] | number[] | (string | number)[];\n      }\n      return obj;\n    }\n    default:\n      throw new Error(`Unknown AST node type: ${JSON.stringify(ast)}`);\n  }\n}\n\nexport function evaluateFormula({\n  formula,\n  data,\n  currentCell,\n  functionBindings,\n  evaluationChain = new Set<string>(),\n}: {\n  formula: string;\n  data: CellStates[];\n  currentCell: CellAddress;\n  functionBindings: FunctionBindingsType;\n  evaluationChain?: Set<string>;\n}): string | number | string[] | number[] | (string | number)[] | object {\n  if (!formula.startsWith(\"=\")) return formula;\n  const currentAddress = cellAddressToString(currentCell);\n  if (evaluationChain.has(currentAddress)) {\n    throw new CircularDependencyError(\n      `Circular dependency detected at ${currentAddress}`\n    );\n  }\n  evaluationChain.add(currentAddress);\n  const tokens = tokenize({\n    input: formula.slice(1),\n    functionBindings,\n  });\n  const ast = parse(tokens);\n  return evaluateAst(ast, data, currentCell, evaluationChain, functionBindings);\n}\n\nexport function getCellDependencies({\n  formula,\n  functionBindings,\n}: {\n  formula: string;\n  functionBindings: FunctionBindingsType;\n}): Set<string> {\n  if (!formula.startsWith(\"=\")) return new Set();\n  const tokens = tokenize({\n    input: formula.slice(1),\n    functionBindings,\n  });\n  const ast = parse(tokens);\n  const dependencies = new Set<string>();\n  function traverse(node: ASTNode) {\n    if (node.type === \"CellReference\") {\n      dependencies.add(\n        cellAddressToString({ col: node.columnIndex, row: node.rowIndex })\n      );\n    } else if (node.type === \"Range\") {\n      const start = { col: node.start.columnIndex, row: node.start.rowIndex };\n      const end = { col: node.end.columnIndex, row: node.end.rowIndex };\n      for (let col = start.col; col <= end.col; col++) {\n        for (let row = start.row; row <= end.row; row++) {\n          dependencies.add(cellAddressToString({ col, row }));\n        }\n      }\n    } else if (\"left\" in node) {\n      traverse(node.left);\n      traverse(node.right);\n    } else if (\"arguments\" in node) {\n      node.arguments.forEach(traverse);\n    }\n  }\n\n  traverse(ast);\n  return dependencies;\n}\n", "import { type FunctionBindingsType } from \"@/types/ast\";\nimport {\n  cellAddressToString,\n  type CellState,\n  type CellStates,\n  stringToCellAddress,\n} from \"@/types/sheet\";\nimport {\n  CircularDependencyError,\n  evaluateFormula,\n  getCellDependencies,\n} from \"../ast/eval\";\n\nexport const updateCellFormula = ({\n  prevData,\n  colIndex,\n  rowIndex,\n  newFormula,\n  functionBindings,\n  display = \"hide\",\n}: {\n  prevData: CellStates[];\n  colIndex: number;\n  rowIndex: number;\n  newFormula: string;\n  functionBindings: FunctionBindingsType;\n  display?: \"wrap\" | \"hide\";\n}) => {\n  const newData = [...prevData];\n  if (!newData[colIndex]) newData[colIndex] = {};\n\n  const cellAddress = cellAddressToString({\n    col: colIndex,\n    row: rowIndex,\n  });\n\n  const oldDependencies =\n    newData[colIndex][rowIndex]?.dependencies || new Set();\n\n  // Calculate the new dependencies\n  const newDependencies = getCellDependencies({\n    formula: newFormula,\n    functionBindings,\n  });\n\n  // Remove this cell from old dependencies' dependents\n  oldDependencies.forEach((dep) => {\n    const { col, row } = stringToCellAddress(dep);\n    if (newData[col]?.[row] && newData[col][row].dependencies !== undefined) {\n      newData[col][row].dependencies.delete(cellAddress);\n    }\n  });\n\n  // Add this cell to new dependencies' dependents\n  newDependencies.forEach((dep) => {\n    const { col, row } = stringToCellAddress(dep);\n    if (!newData[col]) newData[col] = {};\n    if (!newData[col][row]) {\n      newData[col][row] = {\n        value: \"\",\n        display,\n        formula: \"0\",\n        dependencies: new Set(),\n      } satisfies CellState;\n    }\n    if (!newData[col][row].dependencies)\n      newData[col][row].dependencies = new Set();\n    newData[col][row].dependencies.add(cellAddress);\n  });\n\n  // Update the current cell\n  const promises: Record<number, Record<number, Promise<unknown>>> = {};\n  try {\n    const newValue = evaluateFormula({\n      formula: newFormula,\n      data: newData,\n      currentCell: {\n        col: colIndex,\n        row: rowIndex,\n      },\n      functionBindings,\n    });\n    if (newValue instanceof Promise) {\n      newData[colIndex][rowIndex] = {\n        value: \"\",\n        display,\n        formula: newFormula,\n        dependencies: newDependencies,\n      } satisfies CellState;\n      if (!promises[colIndex]) {\n        promises[colIndex] = {};\n      }\n      promises[colIndex][rowIndex] = newValue;\n    } else {\n      newData[colIndex][rowIndex] = {\n        value: newValue,\n        formula: newFormula,\n        dependencies: newDependencies,\n        display,\n      } satisfies CellState;\n    }\n  } catch (error) {\n    if (error instanceof CircularDependencyError) {\n      newData[colIndex][rowIndex] = {\n        value: \"#REF!\",\n        formula: newFormula,\n        dependencies: newDependencies,\n        display,\n        error: \"circular_dependency\",\n      } satisfies CellState;\n    } else {\n      throw error;\n    }\n  }\n  return {\n    cellStates: newData,\n    promises,\n  };\n};\n", "// @/state/update.ts\nimport {\n  DEFAULT_CELL_BORDER_WIDTH,\n  DEFAULT_CELL_HEIGHT,\n  DEFAULT_CELL_PADDING,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_LINE_HEIGHT,\n} from \"@/constants\";\nimport { generateFunctionBody } from \"@/lib/llm\";\nimport { updateCellFormula } from \"@/lib/table/formula\";\nimport { calculateTextHeight } from \"@/lib/utils\";\nimport { Resource } from \"@/types/resource\";\nimport { SecretKeys } from \"@/types/secret\";\nimport {\n  LlmFunctionType,\n  type FunctionBindingsWithFunctionsType,\n  type SheetState,\n  type UpdateCellArgsType,\n} from \"@/types/sheet\";\n\nexport const handleValueUpdate = (\n  state: SheetState,\n  payload: UpdateCellArgsType\n) => {\n  const { row, col, value, display } = payload;\n  const existingCell = state.cellStates[col][row];\n  const displayMode = display || existingCell?.display || \"hide\";\n  let maxRowHeight = 0;\n  const font = `${DEFAULT_FONT_SIZE}px ${DEFAULT_FONT_FAMILY}`;\n  for (let i = 0; i < state.headerStates.length; i++) {\n    const cell = state.cellStates[i][row];\n    if (cell) {\n      const text = i === col ? value : cell.value;\n      const display = i === col ? displayMode : cell.display;\n      const height = calculateTextHeight({\n        text,\n        width:\n          state.headerStates[i].width -\n          DEFAULT_CELL_BORDER_WIDTH * 4 -\n          DEFAULT_CELL_PADDING * 4,\n        font,\n        display,\n        lineHeight: DEFAULT_LINE_HEIGHT,\n      });\n      maxRowHeight = Math.max(maxRowHeight, height, DEFAULT_CELL_HEIGHT);\n    }\n  }\n  const newState: SheetState = {\n    ...state,\n    editingValue: \"\",\n    editingCellPosition: null,\n    cellStates: state.cellStates.map((column, colIndex) =>\n      colIndex === col\n        ? {\n            ...column,\n            [row]: {\n              ...(state.cellStates[colIndex][row] ?? {}),\n              value: value,\n              display: displayMode,\n            },\n          }\n        : column\n    ),\n    rowStates: {\n      ...state.rowStates,\n      [row]: {\n        ...state.rowStates[row],\n        height: maxRowHeight,\n      },\n    },\n  };\n  return newState;\n};\n\nfunction transformFunctionBindings({\n  functionBindings,\n  secretKeys,\n}: {\n  functionBindings: FunctionBindingsWithFunctionsType;\n  secretKeys: SecretKeys;\n}): { [functionName: string]: { id: string; functionBody: string } } {\n  const transformedBindings: {\n    [functionName: string]: { id: string; functionBody: string };\n  } = {};\n  functionBindings.functionBindings.forEach((binding) => {\n    if (binding.function) {\n      if (binding.function.type === \"llm\") {\n        transformedBindings[binding.name.toUpperCase()] = {\n          id: binding.function.id,\n          functionBody: generateFunctionBody({\n            functionData: binding.function as LlmFunctionType & {\n              resource: Resource;\n            },\n            secretKeys,\n          }),\n        };\n      } else {\n        transformedBindings[binding.name.toUpperCase()] = {\n          id: binding.function.id,\n          functionBody: binding.function.functionBody,\n        };\n      }\n    }\n  });\n  return transformedBindings;\n}\n\nexport const handleFormulaUpdate = ({\n  state,\n  payload,\n  functionBindings,\n  secretKeys,\n}: {\n  state: SheetState;\n  payload: UpdateCellArgsType;\n  functionBindings: FunctionBindingsWithFunctionsType;\n  secretKeys: SecretKeys;\n}) => {\n  const { row, col, value, display } = payload;\n  const transformedFunctionBindings = transformFunctionBindings({\n    functionBindings,\n    secretKeys,\n  });\n  const { cellStates, promises } = updateCellFormula({\n    prevData: state.cellStates,\n    colIndex: col,\n    rowIndex: row,\n    newFormula: value,\n    functionBindings: transformedFunctionBindings,\n    display,\n  });\n  return {\n    ...state,\n    editingValue: \"\",\n    editingCellPosition: null,\n    cellStates,\n    promises\n  };\n};\n", "// @/state/sheetReducer.ts\nimport {\n  DEFAULT_CELL_BORDER_WIDTH,\n  DEFAULT_CELL_HEIGHT,\n  DEFAULT_CELL_PADDING,\n  DEFAULT_COLUMN_COUNT,\n  DEFAULT_COLUMN_WIDTH,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_LINE_HEIGHT,\n  DEFAULT_ROW_COUNT,\n} from \"@/constants\";\nimport { SecretKeys } from \"@/types/secret\";\nimport {\n  InsertColumnPayload, SheetAction,\n  type CellState,\n  type CellStates,\n  type ColumnState,\n  type FunctionBindingsWithFunctionsType,\n  type RowState,\n  type SheetState\n} from \"@/types/sheet\"; // Ensure PERFORM_AUTOFILL is imported\nimport { v4 } from \"uuid\";\nimport { calculateTextHeight, generateExcelHeaders, generateFillSequence } from \"../lib/utils\";\nimport { handleSelectedToEditing } from \"./common\";\nimport {\n  handleClear,\n  handleCopy,\n  handlePaste,\n  handleTableKeyboardEvent,\n} from \"./keyboard\";\nimport { handleFormulaUpdate, handleValueUpdate } from \"./update\";\n\nconst DEFAULT_CELL_STATE: CellState = {\n  value: \"\",\n  display: \"hide\",\n};\n\nexport const initialState: SheetState = {\n  id: \"\",\n  name: `Sheet 1`,\n  cellStates: Array.from({ length: DEFAULT_COLUMN_COUNT }, () => ({\n    ...Array.from({ length: DEFAULT_ROW_COUNT }, () => {\n      return {\n        // row col\n        value: ``,\n        display: \"hide\",\n      };\n    }),\n  })),\n  selectedCellPosition: { row: 0, col: 0 },\n  editingCellPosition: null,\n  headerStates: generateExcelHeaders(DEFAULT_COLUMN_COUNT).map((header) => ({\n    value: header,\n    type: \"text\",\n    width: DEFAULT_COLUMN_WIDTH,\n  })),\n  rowStates: {},\n  editingValue: \"\",\n  rowCount: DEFAULT_ROW_COUNT,\n  selectedCellRange: null,\n  selectedRows: [],\n  clipboard: null,\n  undoStack: [],\n  redoStack: [],\n  promises: {},\n  autofillTarget: null,\n};\n\nexport const applyAction = (\n  state: SheetState,\n  action: SheetAction,\n  functionBindings?: FunctionBindingsWithFunctionsType,\n  secretKeys?: SecretKeys\n): SheetState => {\n  switch (action.type) {\n    case \"SET_CELLS\": {\n      const cellMap = action.payload; // `col-row` -> CellState\n      const newCellStates = state.cellStates.map((column, colIndex) => {\n        const updatedColumn = { ...column };\n\n        // Iterate through the cellMap and update relevant cells\n        Object.entries(cellMap).forEach(([key, cellState]) => {\n          const [colStr, rowStr] = key.split(\"-\");\n          const col = parseInt(colStr, 10);\n          const row = parseInt(rowStr, 10);\n\n          if (col === colIndex) {\n            updatedColumn[row] = {\n              ...updatedColumn[row],\n              ...cellState,\n            };\n          }\n        });\n\n        return updatedColumn;\n      });\n\n      return {\n        ...state,\n        cellStates: newCellStates,\n      };\n    }\n    case \"HANDLE_RESIZE_COLUMN\": {\n      const newState = {\n        ...state,\n        headerStates: state.headerStates.map((header, colIndex) =>\n          colIndex === action.payload.colIndex\n            ? { ...header, width: action.payload.width }\n            : header\n        ),\n      };\n      newState.rowStates = Object.fromEntries(\n        Object.entries(newState.rowStates).map(([key, value]) => {\n          const rowIndex = parseInt(key);\n          let maxRowHeight = 0;\n          for (let i = 0; i < newState.headerStates.length; i++) {\n            const cell = newState.cellStates[i][rowIndex];\n            if (cell) {\n              const text = cell.value;\n              const display = cell.display;\n              const height = calculateTextHeight({\n                text,\n                width:\n                  newState.headerStates[i].width -\n                  DEFAULT_CELL_BORDER_WIDTH * 4 -\n                  DEFAULT_CELL_PADDING * 4,\n                font: `${DEFAULT_FONT_SIZE}px ${DEFAULT_FONT_FAMILY}`,\n                lineHeight: DEFAULT_LINE_HEIGHT,\n                display,\n              });\n              maxRowHeight = Math.max(\n                maxRowHeight,\n                height,\n                DEFAULT_CELL_HEIGHT\n              );\n            }\n          }\n          return [key, { ...value, height: maxRowHeight }];\n        })\n      );\n      return newState;\n    }\n    case \"HANDLE_UNCLICKED_TO_CLICKED_CELL\":\n      return {\n        ...state,\n        selectedCellPosition: action.payload,\n        selectedCellRange: null,\n        selectedRows: [],\n        editingCellPosition: null,\n      };\n    case \"HANDLE_DRAG_CELLS\": {\n      if (!state.selectedCellPosition) {\n        return state;\n      }\n      return {\n        ...state,\n        selectedRows: [],\n        selectedCellRange: {\n          start: {\n            row: Math.min(state.selectedCellPosition.row, action.payload.row),\n            col: Math.min(state.selectedCellPosition.col, action.payload.col),\n          },\n          end: {\n            row: Math.max(state.selectedCellPosition.row, action.payload.row),\n            col: Math.max(state.selectedCellPosition.col, action.payload.col),\n          },\n        },\n      };\n    }\n    case \"HANDLE_DOUBLE_CLICK_CELL\": {\n      return handleSelectedToEditing(state);\n    }\n    case \"HANDLE_TABLE_KEYBOARD_EVENT\": {\n      return handleTableKeyboardEvent(state, action.payload);\n    }\n    case \"HANDLE_BLUR_CELL\": {\n      return {\n        ...state,\n        editingValue: \"\",\n        editingCellPosition: null,\n      };\n    }\n    case \"HANDLE_UPDATE_CELL\": {\n      const { value } = action.payload;\n      if (value.startsWith(\"=\")) {\n        if (!functionBindings) {\n          throw new Error(\n            \"Function bindings are required to handle formula updates\"\n          );\n        }\n        if (!secretKeys) {\n          throw new Error(\"Secret keys are required to handle formula updates\");\n        }\n        const res = handleFormulaUpdate({\n          state,\n          payload: action.payload,\n          functionBindings,\n          secretKeys,\n        });\n        const combinedPromises = {\n          ...(state.promises ?? {}),\n          ...(res.promises ?? {}),\n        };\n        return {\n          ...res,\n          promises: combinedPromises,\n          showClipboard: false,\n        };\n      }\n      return {\n        ...handleValueUpdate(state, action.payload),\n        showClipboard: false,\n      };\n    }\n    case \"HANDLE_UPDATE_CELL_RANGE\": {\n      const { range, value, display } = action.payload;\n      const { start, end } = range;\n      const newCellStates = [...state.cellStates];\n      const newRowStates = { ...state.rowStates };\n\n      for (let col = start.col; col <= end.col; col++) {\n        for (let row = start.row; row <= end.row; row++) {\n          const existingCell = state.cellStates[col]?.[row];\n          const displayMode = display || existingCell?.display || \"hide\";\n\n          newCellStates[col] = {\n            ...newCellStates[col],\n            [row]: {\n              value: value ?? existingCell?.value ?? \"\",\n              display: displayMode,\n            },\n          };\n\n          // Recalculate row height\n          let maxRowHeight = 0;\n          for (let i = 0; i < state.headerStates.length; i++) {\n            const cell =\n              i === col\n                ? { value, display: displayMode }\n                : state.cellStates[i]?.[row];\n            const isInRange = i >= start.col && i <= end.col;\n            if (cell) {\n              const text = cell.value ?? \"\";\n              const height = calculateTextHeight({\n                text,\n                width:\n                  state.headerStates[i].width -\n                  DEFAULT_CELL_BORDER_WIDTH * 4 -\n                  DEFAULT_CELL_PADDING * 4,\n                font: `${DEFAULT_FONT_SIZE}px ${DEFAULT_FONT_FAMILY}`,\n                lineHeight: DEFAULT_LINE_HEIGHT,\n                display: isInRange ? display : cell.display,\n              });\n              maxRowHeight = Math.max(\n                maxRowHeight,\n                height,\n                DEFAULT_CELL_HEIGHT\n              );\n            }\n          }\n\n          newRowStates[row] = {\n            ...newRowStates[row],\n            height: maxRowHeight,\n          };\n        }\n      }\n\n      return {\n        ...state,\n        cellStates: newCellStates,\n        rowStates: newRowStates,\n      };\n    }\n    case \"SET_SELECTED_CELL_POSITION\":\n      return {\n        ...state,\n        selectedCellPosition: action.payload,\n        selectedRows: [],\n        selectedCellRange: null,\n      };\n    case \"SET_EDITING_CELL_POSITION\":\n      return { ...state, editingCellPosition: action.payload };\n    case \"INSERT_ROW\": {\n      const { rowIndex, rowData } = action.payload;\n\n      // Create new cellStates with the row inserted\n      const newCellStates = state.cellStates.map((column, colIndex) => {\n        const newColumn = { ...column };\n\n        // Shift cell states down for rows at or below the insertion point\n        Object.keys(column)\n          .map(Number)\n          .sort((a, b) => b - a)\n          .forEach((rowKey) => {\n            if (rowKey >= rowIndex) {\n              newColumn[rowKey + 1] = column[rowKey];\n            }\n          });\n\n        // Insert the new row data if provided\n        if (rowData && rowData.cellStates[colIndex]) {\n          newColumn[rowIndex] = rowData.cellStates[colIndex];\n        } else {\n          newColumn[rowIndex] = DEFAULT_CELL_STATE;\n        }\n\n        return newColumn;\n      });\n\n      // Shift rowStates down and insert new rowState\n      const newRowStates: { [key: number]: RowState } = {};\n      Object.keys(state.rowStates)\n        .map(Number)\n        .sort((a, b) => b - a)\n        .forEach((key) => {\n          if (key >= rowIndex) {\n            newRowStates[key + 1] = state.rowStates[key];\n          } else {\n            newRowStates[key] = state.rowStates[key];\n          }\n        });\n\n      // Insert the new rowState if provided\n      if (rowData && rowData.rowState) {\n        newRowStates[rowIndex] = rowData.rowState;\n      } else {\n        newRowStates[rowIndex] = {\n          height: DEFAULT_CELL_HEIGHT,\n          specifiedHeight: null,\n          hidden: false,\n        };\n      }\n\n      return {\n        ...state,\n        cellStates: newCellStates,\n        rowStates: newRowStates,\n      };\n    }\n    case \"SET_EDITING_VALUE\":\n      return { ...state, editingValue: action.payload };\n    case \"DELETE_ROWS\": {\n      const rowsToDelete = action.payload.sort((a, b) => b - a); // Sort descending\n      let newCellStates = [...state.cellStates];\n      const newRowStates = { ...state.rowStates };\n\n      for (const rowIndex of rowsToDelete) {\n        // Remove row from cellStates\n        newCellStates = newCellStates.map((column) => {\n          const newColumn = { ...column };\n          delete newColumn[rowIndex];\n          // Shift cells up for rows below the deleted row\n          Object.keys(newColumn)\n            .map(Number)\n            .filter((key) => key > rowIndex)\n            .sort((a, b) => a - b)\n            .forEach((key) => {\n              newColumn[key - 1] = newColumn[key];\n              delete newColumn[key];\n            });\n          return newColumn;\n        });\n\n        // Remove rowState\n        delete newRowStates[rowIndex];\n        // Shift rowStates up for rows below the deleted row\n        Object.keys(newRowStates)\n          .map(Number)\n          .filter((key) => key > rowIndex)\n          .sort((a, b) => a - b)\n          .forEach((key) => {\n            newRowStates[key - 1] = newRowStates[key];\n            delete newRowStates[key];\n          });\n      }\n\n      return {\n        ...state,\n        cellStates: newCellStates,\n        rowStates: newRowStates,\n      };\n    }\n    case \"INSERT_COLUMN\": {\n      const { colIndex, columnState, cellStates } = action.payload;\n\n      // Define default column state if not provided\n      const defaultColumnState: ColumnState = {\n        value: `column_${colIndex + 1}`,\n        type: \"text\",\n        width: DEFAULT_COLUMN_WIDTH,\n      };\n\n      // Define default cell states if not provided\n      const defaultCellStates: CellStates = {};\n      for (let row = 0; row < state.rowCount; row++) {\n        defaultCellStates[row] = {\n          value: \"\",\n          display: \"hide\",\n        };\n      }\n\n      const newCellStates = [\n        ...state.cellStates.slice(0, colIndex),\n        cellStates || defaultCellStates, // Ensure it's a Record<number, CellState>\n        ...state.cellStates.slice(colIndex),\n      ];\n\n      const newHeaderStates = [\n        ...state.headerStates.slice(0, colIndex),\n        columnState || defaultColumnState,\n        ...state.headerStates.slice(colIndex),\n      ];\n\n      return {\n        ...state,\n        cellStates: newCellStates,\n        headerStates: newHeaderStates,\n      };\n    }\n    case \"DELETE_COLUMN\":\n      return {\n        ...state,\n        cellStates: state.cellStates.filter(\n          (_, colIndex) => colIndex !== action.payload\n        ),\n        headerStates: state.headerStates.filter(\n          (_, colIndex) => colIndex !== action.payload\n        ),\n      };\n    case \"CLEAR_CELLS\": {\n      return handleClear(action, state);\n    }\n    case \"FORMAT_CELLS\": {\n      const {\n        start: formatStart,\n        end: formatEnd,\n        fontFamily,\n        fontSize,\n      } = action.payload;\n      return {\n        ...state,\n        cellStates: state.cellStates.map((column, colIndex) => {\n          const newColumn = { ...column };\n          for (\n            let rowIndex = formatStart.row;\n            rowIndex <= formatEnd.row;\n            rowIndex++\n          ) {\n            if (colIndex >= formatStart.col && colIndex <= formatEnd.col) {\n              newColumn[rowIndex] = {\n                ...newColumn[rowIndex],\n                fontFamily,\n                fontSize,\n              };\n            }\n          }\n          return newColumn;\n        }),\n      };\n    }\n    case \"HANDLE_RESIZE_ROWS\": {\n      const rows = action.payload;\n      const newRowStates: { [row: number]: RowState } = {};\n      rows.forEach(({ rowIndex, height }) => {\n        newRowStates[rowIndex] = {\n          ...state.rowStates[rowIndex],\n          specifiedHeight: height,\n        };\n      });\n      return {\n        ...state,\n        rowStates: {\n          ...state.rowStates,\n          ...newRowStates,\n        },\n      };\n    }\n    case \"HANDLE_DRAG_ROWS\":\n      return {\n        ...state,\n        selectedRows: action.payload.sort((a, b) => a - b),\n        selectedCellRange: null,\n        selectedCellPosition: null,\n      };\n    case \"SET_SHEET_NAME\":\n      return {\n        ...state,\n        name: action.payload,\n      };\n    case \"COPY_CELLS\": {\n      return handleCopy(action, state);\n    }\n    case \"PASTE_CELLS\": {\n      return handlePaste(action, state);\n    }\n    case \"INSERT_ROWS\": {\n      const { rows } = action.payload;\n\n      // Sort rows in ascending order of rowIndex to avoid conflicts during insertion\n      const sortedRows = [...rows].sort((a, b) => a.rowIndex - b.rowIndex);\n\n      let newState = state;\n      for (const row of sortedRows) {\n        // For each row, create an INSERT_ROW action and apply it\n        const insertRowAction: SheetAction = {\n          type: \"INSERT_ROW\",\n          payload: {\n            rowIndex: row.rowIndex,\n            rowData: row.rowData,\n          },\n        };\n        newState = applyAction(\n          newState,\n          insertRowAction,\n          functionBindings,\n          secretKeys\n        );\n      }\n\n      return newState;\n    }\n    case \"UNDO\": {\n      if (state.undoStack.length === 0) return state;\n      const inverseAction = state.undoStack[0];\n      const newUndoStack = state.undoStack.slice(1, state.undoStack.length);\n      const originalAction = getInverseAction(state, inverseAction);\n      const newRedoStack = [...state.redoStack];\n      if (originalAction) {\n        newRedoStack.unshift(originalAction);\n      }\n      const newState = applyAction(\n        state,\n        inverseAction,\n        functionBindings,\n        secretKeys\n      );\n      return {\n        ...newState,\n        undoStack: newUndoStack.slice(0, 500),\n        redoStack: newRedoStack.slice(0, 500),\n      };\n    }\n    case \"REDO\": {\n      if (state.redoStack.length === 0) return state;\n      const redoAction = state.redoStack[0];\n      const newRedoStack = state.redoStack.slice(1, state.redoStack.length);\n      const originalAction = getInverseAction(state, redoAction);\n      const newUndoStack = [...state.undoStack];\n      if (originalAction) {\n        newUndoStack.unshift(originalAction);\n      }\n      const newState = applyAction(\n        state,\n        redoAction,\n        functionBindings,\n        secretKeys\n      );\n      return {\n        ...newState,\n        undoStack: newUndoStack.slice(0, 500),\n        redoStack: newRedoStack.slice(0, 500),\n      };\n    }\n    case \"INITIATE_AUTOFILL\": {\n      // You might want to set some state to indicate autofill has started\n      return state;\n    }\n\n    case \"UPDATE_AUTOFILL_TARGET\": {\n      const { endRow, endCol } = action.payload;\n      return {\n        ...state,\n        autofillTarget: { row: endRow, col: endCol },\n      };\n    }\n\n    case \"PERFORM_AUTOFILL\": {\n      const { fillRange } = action.payload;\n\n      // Determine the source range for autofill\n      let sourceRange;\n      if (state.selectedCellRange) {\n        sourceRange = state.selectedCellRange;\n      } else if (state.selectedCellPosition) {\n        sourceRange = {\n          start: state.selectedCellPosition,\n          end: state.selectedCellPosition,\n        };\n      } else {\n        console.warn(\"No source range for autofill\");\n        return state;\n      }\n\n      // Collect existing data from the source range to determine the pattern\n      const dataToFill: { [key: string]: CellState } = {};\n\n      for (let col = sourceRange.start.col; col <= sourceRange.end.col; col++) {\n        for (let row = sourceRange.start.row; row <= sourceRange.end.row; row++) {\n          const key = `${col}-${row}`;\n          const cellState = state.cellStates[col]?.[row];\n          if (cellState) {\n            dataToFill[key] = cellState;\n          }\n        }\n      }\n      \n      // Generate filled data using utility functions\n      const filledData = generateFillSequence(dataToFill, fillRange);\n\n      // Update cellStates and rowStates\n      const newCellStates: SheetState['cellStates'] = [...state.cellStates];\n      const newRowStates = { ...state.rowStates };\n\n      Object.entries(filledData).forEach(([key, cellState]) => {\n        const [colStr, rowStr] = key.split(\"-\");\n        const col = parseInt(colStr, 10);\n        const row = parseInt(rowStr, 10);\n\n        if (!newCellStates[col]) {\n          newCellStates[col] = {};\n        }\n        newCellStates[col][row] = {\n          ...newCellStates[col][row],\n          ...cellState,\n        };\n\n        // Recalculate row height if necessary\n        const text = cellState.value || \"\";\n        const height = calculateTextHeight({\n          text,\n          width:\n            state.headerStates[col].width -\n            DEFAULT_CELL_BORDER_WIDTH * 4 -\n            DEFAULT_CELL_PADDING * 4,\n          font: `${DEFAULT_FONT_SIZE}px ${DEFAULT_FONT_FAMILY}`,\n          lineHeight: DEFAULT_LINE_HEIGHT,\n          display: cellState.display || \"wrap\",\n        });\n        newRowStates[row] = {\n          ...newRowStates[row],\n          height: Math.max(height, DEFAULT_CELL_HEIGHT),\n        };\n      });\n\n      return {\n        ...state,\n        cellStates: newCellStates,\n        rowStates: newRowStates,\n        autofillTarget: null, // Reset autofill target after completion\n      };\n    }\n    default:\n      return state;\n  }\n};\n\nexport const getInverseAction = (\n  sheetState: SheetState,\n  action: SheetAction\n) => {\n  switch (action.type) {\n    case \"HANDLE_RESIZE_COLUMN\": {\n      const { colIndex } = action.payload;\n      const previousWidth = sheetState.headerStates[colIndex].width;\n      const inverseAction: SheetAction = {\n        type: \"HANDLE_RESIZE_COLUMN\",\n        payload: { colIndex, width: previousWidth },\n      };\n      return inverseAction;\n    }\n    case \"HANDLE_UPDATE_CELL\": {\n      const { col, row } = action.payload;\n      const previousCellData = sheetState.cellStates[col][row];\n      const inverseAction: SheetAction = {\n        type: \"HANDLE_UPDATE_CELL\",\n        payload: {\n          col,\n          row,\n          value: previousCellData.value,\n          display: previousCellData.display,\n        },\n      };\n      return inverseAction;\n    }\n    case \"INSERT_ROW\": {\n      const { rowIndex } = action.payload;\n      const inverseAction: SheetAction = {\n        type: \"DELETE_ROWS\",\n        payload: [rowIndex],\n      };\n      return inverseAction;\n    }\n    case \"DELETE_ROWS\": {\n      const deletedRows = action.payload; // Array of row indices\n      const deletedRowData = deletedRows.map((rowIndex) => ({\n        rowIndex,\n        rowState: sheetState.rowStates[rowIndex],\n        cellStates: sheetState.cellStates.map((column) => column[rowIndex]),\n      }));\n\n      // We need to handle multiple rows, so we'll create an \"INSERT_ROWS\" action\n      const inverseAction: SheetAction = {\n        type: \"INSERT_ROWS\",\n        payload: {\n          rows: deletedRowData,\n        },\n      };\n      return inverseAction;\n    }\n    case \"INSERT_COLUMN\": {\n      const { colIndex } = action.payload;\n      const inverseAction: SheetAction = {\n        type: \"DELETE_COLUMN\",\n        payload: colIndex,\n      };\n      return inverseAction;\n    }\n    case \"DELETE_COLUMN\": {\n      const deletedColIndex = action.payload;\n      const deletedColumnState = sheetState.headerStates[deletedColIndex];\n      const deletedCellStates = sheetState.cellStates[deletedColIndex];\n\n      const deletedColumnData: InsertColumnPayload = {\n        colIndex: deletedColIndex,\n        columnState: deletedColumnState,\n        cellStates: deletedCellStates, // Record<number, CellState>\n      };\n\n      const inverseAction: SheetAction = {\n        type: \"INSERT_COLUMN\",\n        payload: deletedColumnData, // Now matches InsertColumnPayload with Record<number, CellState>\n      };\n      return inverseAction;\n    }\n    case \"MOVE_COLUMN\": {\n      const { fromIndex, toIndex } = action.payload;\n      const inverseAction: SheetAction = {\n        type: \"MOVE_COLUMN\",\n        payload: { fromIndex: toIndex, toIndex: fromIndex },\n      };\n      return inverseAction;\n    }\n    case \"CLEAR_CELLS\": {\n      const { start, end } = action.payload;\n      const previousData: Record<string, CellState> = {};\n      for (let col = start.col; col <= end.col; col++) {\n        for (let row = start.row; row <= end.row; row++) {\n          previousData[`${col}-${row}`] = sheetState.cellStates[col][row];\n        }\n      }\n      const inverseAction: SheetAction = {\n        type: \"HANDLE_UPDATE_CELL_RANGE\",\n        payload: {\n          range: { start, end },\n          previousData, // Extend payload to include previous data\n        },\n      };\n      return inverseAction;\n    }\n    case \"FORMAT_CELLS\": {\n      const { start, end } = action.payload;\n      const previousCellStates: Record<string, CellState> = {};\n\n      for (let col = start.col; col <= end.col; col++) {\n        for (let row = start.row; row <= end.row; row++) {\n          previousCellStates[`${col}-${row}`] = {\n            ...sheetState.cellStates[col][row],\n          };\n        }\n      }\n\n      const inverseAction: SheetAction = {\n        type: \"SET_CELLS\",\n        payload: previousCellStates,\n      };\n\n      return inverseAction;\n    }\n    case \"HANDLE_RESIZE_ROWS\": {\n      const resizedRows = action.payload;\n      const previousHeights = resizedRows.map(({ rowIndex }) => ({\n        rowIndex,\n        height: sheetState.rowStates[rowIndex].height,\n      }));\n      const inverseAction: SheetAction = {\n        type: \"HANDLE_RESIZE_ROWS\",\n        payload: previousHeights,\n      };\n      return inverseAction;\n    }\n    case \"PASTE_CELLS\": {\n      const { target, sourceData } = action.payload;\n      // Ensure sourceData exists to restore previous state\n      if (!sourceData) {\n        console.warn(\"No sourceData provided for inverse PASTE_CELLS action.\");\n        return null;\n      }\n      const inverseAction: SheetAction = {\n        type: \"PASTE_CELLS\",\n        payload: {\n          target,\n          sourceData, // Restore previous data\n        },\n      };\n      return inverseAction;\n    }\n    default:\n      return null;\n  }\n};", "// @/hooks/useSpreadsheetes.ts\nimport { localForageInstance } from \"@/lib/storage\";\nimport { initialState } from \"@/state/sheetReducer\";\nimport { CreateSpreadsheetArgs, Spreadsheet } from \"@/types/sheet\";\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useEffect, useState } from \"react\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { z } from \"zod\";\n\nexport const KEY = \"spreadsheets\";\n\n/**\n * useCreateSpreadsheet\n *\n * Hook to create a new spreadsheet.\n */\nexport const useCreateSpreadsheet = () => {\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationKey: [\"createSpreadsheet\"],\n    mutationFn: async (args: z.infer<typeof CreateSpreadsheetArgs>) => {\n      const spreadsheets =\n        (await localForageInstance.getItem<Spreadsheet[]>(KEY)) || [];\n      const newSpreadsheet: Spreadsheet = {\n        id: uuidv4(),\n        name: args.name || \"Untitled Spreadsheet\",\n        lastOpenedAt: new Date().toISOString(),\n        sheets: [\n          {\n            ...initialState,\n            id: uuidv4(),\n          },\n        ], // Initialize with default sheets if needed\n      };\n      spreadsheets.push(newSpreadsheet);\n      await localForageInstance.setItem(KEY, spreadsheets);\n      queryClient.setQueryData<Spreadsheet[]>([\"spreadsheets\"], spreadsheets);\n      queryClient.setQueryData<Spreadsheet>(\n        [\"spreadsheet\", newSpreadsheet.id],\n        newSpreadsheet\n      );\n      return newSpreadsheet;\n    },\n  });\n};\n\n/**\n * useDeleteSpreadsheet\n *\n * Hook to delete an existing spreadsheet by ID.\n */\nexport const useDeleteSpreadsheet = () => {\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationKey: [\"deleteSpreadsheet\"],\n    mutationFn: async (id: string) => {\n      const spreadsheets =\n        (await localForageInstance.getItem<Spreadsheet[]>(KEY)) || [];\n      const updatedSpreadsheets = spreadsheets.filter(\n        (sheet) => sheet.id !== id\n      );\n      await localForageInstance.setItem(KEY, updatedSpreadsheets);\n      queryClient.removeQueries({ queryKey: [\"spreadsheet\", id] });\n      queryClient.setQueryData<Spreadsheet[]>(\n        [\"spreadsheets\"],\n        updatedSpreadsheets\n      );\n    },\n  });\n};\n\n/**\n * useUpdateSpreadsheet\n *\n * Hook to update an existing spreadsheet's details.\n */\nexport const useUpdateSpreadsheet = () => {\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationKey: [\"updateSpreadsheet\"],\n    mutationFn: async (updatedSpreadsheet: Spreadsheet) => {\n      const spreadsheets =\n        (await localForageInstance.getItem<Spreadsheet[]>(KEY)) || [];\n      const newSpreadsheets = spreadsheets.map((sheet) =>\n        sheet.id === updatedSpreadsheet.id ? updatedSpreadsheet : sheet\n      );\n      await localForageInstance.setItem(KEY, newSpreadsheets);\n      queryClient.setQueryData<Spreadsheet[]>(\n        [\"spreadsheets\"],\n        newSpreadsheets\n      );\n      queryClient.setQueryData<Spreadsheet>(\n        [\"spreadsheet\", updatedSpreadsheet.id],\n        updatedSpreadsheet\n      );\n      return updatedSpreadsheet;\n    },\n  });\n};\n\nexport async function updateSheet(\n  spreadsheetId: string,\n  sheet: Spreadsheet[\"sheets\"][0]\n) {\n  const spreadsheets =\n    (await localForageInstance.getItem<Spreadsheet[]>(KEY)) || [];\n  const updatedSpreadsheets = spreadsheets.map((spreadsheet) => {\n    if (spreadsheet.id === spreadsheetId) {\n      const updatedSheets = spreadsheet.sheets.map((s) =>\n        s.id === sheet.id ? sheet : s\n      );\n      return { ...spreadsheet, sheets: updatedSheets };\n    }\n    return spreadsheet;\n  });\n  await localForageInstance.setItem(KEY, updatedSpreadsheets);\n  return updatedSpreadsheets;\n}\n\n/**\n * useUpdateSheet\n *\n * Hook to update a specific sheet within a spreadsheet.\n */\nexport const useUpdateSheet = () => {\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationKey: [\"updateSheet\"],\n    mutationFn: async ({\n      spreadsheetId,\n      sheet,\n    }: {\n      spreadsheetId: string;\n      sheet: Spreadsheet[\"sheets\"][0];\n    }) => {\n      const updatedSpreadsheets = await updateSheet(spreadsheetId, sheet);\n      queryClient.setQueryData<Spreadsheet[]>(\n        [\"spreadsheets\"],\n        updatedSpreadsheets\n      );\n      queryClient.invalidateQueries({\n        queryKey: [\"spreadsheet\", spreadsheetId],\n      });\n      return;\n    },\n  });\n};\n\nexport const getSpreadsheet = async (spreadsheetId: string) => {\n  const spreadsheets =\n    (await localForageInstance.getItem<Spreadsheet[]>(KEY)) || [];\n  return spreadsheets.find((sheet) => sheet.id === spreadsheetId);\n};\n\n/**\n * useSpreadsheet\n *\n * Hook to fetch a single spreadsheet by ID.\n */\nexport const useSpreadsheet = (id: string) => {\n  const [spreadsheet, setSpreadsheet] = useState<Spreadsheet | null>(null);\n  const [isPending, setIsPending] = useState(true);\n\n  useEffect(() => {\n    const _getSpreadsheet = async (spreadsheetId: string) => {\n      setIsPending(true);\n      const res = await getSpreadsheet(spreadsheetId);\n      if (!res) {\n        throw new Error(\"Spreadsheet not found\");\n      }\n      setSpreadsheet(res);\n      setIsPending(false);\n    };\n    void _getSpreadsheet(id);\n  }, [id]);\n  return {\n    data: spreadsheet,\n    isPending,\n  };\n};\n\n/**\n * useSpreadsheets\n *\n * Hook to fetch all spreadsheets.\n */\nexport const useSpreadsheets = () => {\n  return useQuery({\n    queryKey: [\"spreadsheets\"],\n    queryFn: async () => {\n      const spreadsheets =\n        (await localForageInstance.getItem<Spreadsheet[]>(KEY)) || [];\n      if (spreadsheets.length === 0) {\n        // Initialize with default spreadsheets if necessary\n        const defaultSpreadsheets: Spreadsheet[] = [];\n        await localForageInstance.setItem(KEY, defaultSpreadsheets);\n        return defaultSpreadsheets;\n      }\n      return spreadsheets;\n    },\n  });\n};\n"],
  "mappings": "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",
  "names": ["display"]
}
